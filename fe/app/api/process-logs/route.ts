import { NextRequest, NextResponse } from 'next/server';
import OpenAI from 'openai';
import fs from 'fs';
import path from 'path';

// Initialize OpenAI client
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

interface EventOverview {
  event: string;
  timestamp?: string;
  overview: string;
  vulnerability: boolean;
  vulnerability_details: string;
}

interface OverviewResponse {
  overview: EventOverview[];
  summary: {
    total_events: number;
    analysis_timestamp: string;
    output_file?: string;
    file_path?: string;
    total_entries_in_file?: number;
    new_entries_added?: number;
  };
}

export async function POST(request: NextRequest) {
  try {
    // Check for OpenAI API key
    if (!process.env.OPENAI_API_KEY) {
      return NextResponse.json(
        { error: 'OpenAI API key not configured. Please set OPENAI_API_KEY in .env.local' },
        { status: 401 }
      );
    }

    // Parse the JSON body
    const body = await request.json();
    
    if (!body || typeof body !== 'object') {
      return NextResponse.json(
        { error: 'Invalid JSON provided. Please provide a valid JSON object or array.' },
        { status: 400 }
      );
    }

    // Flatten all events into a single array, regardless of structure
    let events: any[] = [];
    
    function extractEvents(obj: any): void {
      if (Array.isArray(obj)) {
        // If it's an array, process each item
        obj.forEach(item => extractEvents(item));
      } else if (obj && typeof obj === 'object') {
        if (obj.event) {
          // If this object has an 'event' property, it's a log event
          events.push(obj);
        } else {
          // Otherwise, recursively search nested objects
          Object.values(obj).forEach(value => extractEvents(value));
        }
      }
    }
    
    extractEvents(body);

    if (events.length === 0) {
      return NextResponse.json(
        { error: 'No events found to analyze.' },
        { status: 400 }
      );
    }

    // Limit to reasonable number of events for API limits
    const limitedEvents = events.slice(0, 50);

    // Build prompt for GPT-4o
    const eventsText = limitedEvents.map((event, index) => {
      const eventStr = JSON.stringify(event, null, 2);
      return `Event ${index + 1}:\n${eventStr}`;
    }).join('\n\n');

    const prompt = `Analyze these workflow execution events and provide a quick overview of each event. Focus on what happened, its significance, and any potential security vulnerabilities.

EVENTS:
${eventsText}

For each event, analyze for potential vulnerabilities such as:
- Authentication/authorization issues
- Data exposure or leaks
- Injection vulnerabilities
- Insecure configurations
- Error handling that reveals sensitive info
- Privilege escalation
- Input validation issues
- Any suspicious patterns or anomalies

Return ONLY this JSON format:
{
  "overview": [
    {
      "event": "event_name_from_log",
      "timestamp": "timestamp_if_available", 
      "overview": "Brief description of what this event represents and its significance",
      "vulnerability": true/false,
      "vulnerability_details": "Detailed explanation of vulnerability if found, or 'No vulnerabilities detected' if clean"
    }
  ]
}

Be thorough in vulnerability analysis but concise in descriptions. Flag anything potentially suspicious.`;

    try {
      const response = await openai.chat.completions.create({
        model: 'gpt-4o',
        messages: [
          {
            role: 'system',
            content: 'You are a workflow analysis expert. Return ONLY valid JSON. No explanations or markdown.'
          },
          {
            role: 'user',
            content: prompt
          }
        ],
        temperature: 0.3,
        max_tokens: 2000
      });

      const analysisText = response.choices[0]?.message?.content;
      
      if (!analysisText) {
        throw new Error('No analysis generated by GPT-4o');
      }

      // Clean the GPT response: remove markdown code block fences if present
      const cleanedAnalysisText = analysisText.replace(/^```json\n/, '').replace(/\n```$/, '');

      // Parse the GPT response
      let analysis;
      try {
        console.log('Raw GPT response:', analysisText);
        console.log('Cleaned GPT response for parsing:', cleanedAnalysisText); // Log the cleaned text
        analysis = JSON.parse(cleanedAnalysisText); // Use the cleaned text for parsing
        if (!analysis.overview || !Array.isArray(analysis.overview)) {
          throw new Error('Invalid analysis format from GPT-4o');
        }
        
        // Validate that each overview has required fields
        analysis.overview = analysis.overview.map((item: any) => ({
          event: item.event || 'unknown_event',
          timestamp: item.timestamp || new Date().toISOString(),
          overview: item.overview || 'No overview provided',
          vulnerability: typeof item.vulnerability === 'boolean' ? item.vulnerability : false,
          vulnerability_details: item.vulnerability_details || 'No vulnerability analysis available'
        }));
        
      } catch (parseError) {
        console.error('GPT analysis parse error:', parseError);
        console.error('Failed response text:', analysisText);
        // Fallback: create basic overview
        analysis = {
          overview: limitedEvents.map((event, index) => ({
            event: event.event || `event_${index + 1}`,
            timestamp: event.timestamp || new Date().toISOString(),
            overview: `Basic analysis: ${event.event || 'unknown event'} occurred`,
            vulnerability: false,
            vulnerability_details: 'No vulnerability analysis available - parsing failed'
          }))
        };
      }

      const result: OverviewResponse = {
        overview: analysis.overview,
        summary: {
          total_events: limitedEvents.length,
          analysis_timestamp: new Date().toISOString()
        }
      };

      // Save/append to single processed_logs.json file
      try {
        const filename = 'processed_logs.json';
        const filePath = path.join(process.cwd(), filename);
        
        // Read existing data if file exists
        let existingData: any[] = [];
        if (fs.existsSync(filePath)) {
          try {
            const existingContent = fs.readFileSync(filePath, 'utf8');
            const parsed = JSON.parse(existingContent);
            existingData = Array.isArray(parsed) ? parsed : [];
          } catch (parseError) {
            console.warn('Could not parse existing processed_logs.json, starting fresh');
            existingData = [];
          }
        }
        
        // Create new entries with overview data
        const newEntries = analysis.overview.map((overview: any, index: number) => ({
          event: overview.event,
          timestamp: overview.timestamp,
          overview: overview.overview,
          vulnerability: overview.vulnerability || false,
          vulnerability_details: overview.vulnerability_details || 'No vulnerability analysis available',
          original_data: limitedEvents[index] || {},
          processed_at: new Date().toISOString()
        }));
        
        // Append new entries to existing data
        const updatedData = [...existingData, ...newEntries];
        
        // Write back to file
        fs.writeFileSync(filePath, JSON.stringify(updatedData, null, 2));
        
        // Add file info to response
        result.summary = {
          ...result.summary,
          output_file: filename,
          file_path: filePath,
          total_entries_in_file: updatedData.length,
          new_entries_added: newEntries.length
        };
        
        console.log(`âœ… Added ${newEntries.length} new entries to ${filename} (total: ${updatedData.length})`);
      } catch (fileError) {
        console.error('Failed to save processed logs to file:', fileError);
        // Don't fail the request if file writing fails
      }

      return NextResponse.json(result);

    } catch (openaiError: any) {
      console.error('OpenAI API error:', openaiError);
      
      if (openaiError.code === 'invalid_api_key') {
        return NextResponse.json(
          { error: 'Invalid OpenAI API key. Check your environment configuration.' },
          { status: 401 }
        );
      }

      if (openaiError.code === 'insufficient_quota') {
        return NextResponse.json(
          { error: 'OpenAI API quota exceeded. Please check your billing.' },
          { status: 429 }
        );
      }

      return NextResponse.json(
        { error: 'OpenAI analysis failed', details: openaiError.message },
        { status: 500 }
      );
    }

  } catch (error: any) {
    console.error('Overview analysis error:', error);
    
    return NextResponse.json(
      { error: 'Analysis failed', details: error.message },
      { status: 500 }
    );
  }
} 